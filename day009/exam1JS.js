/*
객체지향 프로그래밍
- 객체(Object): 주체(나/대상)가 아닌 모든 다른 실체(타인)
- 주체(Subject): '나/대상'이라는 실체, 중심.
- 본인은 객체가 될 수도 있고 주체가 될 수도 있다.
    - 주체를 무엇으로 두느냐에 따라 객체가 달라진다. !!
- 세상에 있는 것들은 주체-객체 구조. 절차지향프로그래밍보다 세상을 컴퓨터로 옮기기 용이하다.

프로퍼티(속성)
- ' 'name': '홍길동 ' -> 프로퍼티
- 'name' -> key (키)(프로퍼티 명)
- '홍길동' -> value (값)(프로퍼티값)

-장점: 객체 각각의 구분이 편해서 유지보수 편리.
-단점: 복잡함.
*/

/*
JS 객체

- 클래스 기반 객체: class(객체를 만들기 위한 틀/설계도) vs. 클래스가 없는 객체: {}

배열: []. 인덱스, 자료 순서 있다. , 여러 개 목록.
    -> 같은 분류(타입) 여러 개 자료 저장할 때 사용.
    -> 예] ['이름', '이름', '이름', '이름']
객체: {}. 속성명, 자료 순서 없다. , 하나의 정보로 묶을 때.
    -> 서로 다른 분류(타입) 여러 개 자료 저장할 때 사용.
    -> 예] {이름: '홍길동', 나이: 24, 주민번호: '모름'}

    -> const1 = [ 10, 'hello'] -->> 이러면 욕먹음
       const2 = { i: 10, w: 'hellol } -->> i처럼 분류 이름 만들어서 나눠주기.
                                           자료 딱 봤을 때 이게 무슨 숫자고 단어인지 모르기 때문.
*/

// [1] 객체 선언 방법
{ }

// [2] 선언한 객체를 변수에 대입
let obj1 = { };

// [3] 객체 선언과 동시에 속성{ 속성명: 값 } 정의/구성
// 3-1: 속성명과 속성값은 하나의 쌍 (엔트리=entry 또는 프로퍼티=propertie)
//      쉼표로 쌍을 구분한다.
// 3-2: 속성명은 문자취급하며, 특수문자가 들어간 경우 "" 또는 ''로 감싼다. "#$우#$@"
// 3-3: 속성명은 자료(속성값)를 식별하는 목적으로 동일한 객체 내 중복 불가능하다.
let obj2 = { 속성명1 : 10, 속성명2 : "hello"};
/*let age = 10 ; 
let name = "유재석" ;
vs.
{ age: 10 , name: "유재석"}   이게 낫대*/

// [4] 객체 호출: .(점=pointer)(접근/도트 연산자) 이란? 앞에 있는 항의 주소값(위치/포인터)으로 이동.
console.log( obj2 ) ; // 모든 객체 정보 출력. console이라는 객체가 log이라는 함수를
console.log( obj2.속성명1) ; // 객체변수명.속성명
//obj2. : obj2로 이동해라 , obj2.속성명1 : obj2로 이동해서 속성명1 호출해라.
// 경기도.안양시.만안구.성결대.공부하기(); // 행동(함수)은 행.
console.log( Object.keys( obj2 )); // 객체 내 속성명(key)들을 배열로 호출 가능. 속성명들만!
console.log( Object.values( obj2 )); //객체 내 값(value)들을 배열로 호출 가능.
console.log( Object.entries( obj2 )); //객체 내 엔트리(entry)들 호출 가능. ['속성명1', 10] ['속성명2', 'hello']

// [5] 객체 속성(엔트리) 추가: 객체변수명.새로운속성명 = 값
obj2.속성명3 = true;
console.log( Object.entries( obj2 ));

// [6] 객체 속성 값 수정: 객체변수명.수정할속성명 = 새로운 값, 주의!!: 수정할속성명이 존재하지 않으면 수정이 아니라 추가가 된다.
obj2.속성명3 = false;
console.log( Object.entries( obj2 ));

// [7] 객체 속성 삭제: delete 객체변수명.속성명;
delete obj2.속성명3;
console.log( Object.entries( obj2 ));
    // JS는 브라우저 안에 종속되기 때문에 변수를 직접 지우지 않아도 브라우저 끄면 삭제됨 (변수 자체를 삭제하는 건 없다는 말.)
    // (나중에 함) 가비지컬렉터: 변수에 저장되지 않은 일회용 자료는 쓰레기 처리 됨. { } or '하하' or 3
    // 객체를 삭제하고 싶으면 덮어쓰거나
    obj2 = {}; //이렇게 쓰레기 언어로 만들어서 가비지컬렉터가 삭제하도록.

// [8] 객체 속성 내 자료는 모든 자료형(타입) 가능하다.
let obj3 = { a: 1 , b: "안녕", c: true, d: [1 , 2], e: {aa: 1, bb: "안녕"}}

// [9] in 연산자: '찾을속성명' in 객치변수명. 해당 객체 내 속성이 있는지 확인(true/false)
console.log( 'f' in obj3 ); //false
console.log( 'a' in obj3 ); //true


/*
공공데이터포털 사용
*/